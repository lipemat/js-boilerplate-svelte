import fs, {existsSync, readFileSync} from 'fs';
import type {Plugin, UserConfig, ViteDevServer} from 'vite';
import camelCase from '@lipemat/js-boilerplate/helpers/camel-case';
import {basename} from 'path';
import localByDefault from 'postcss-modules-local-by-default';
import extractImports from 'postcss-modules-extract-imports';
import modulesScope from 'postcss-modules-scope';
import postcss from 'postcss';
import {unlinkSync} from 'node:fs';


/**
 * Formats the content of a TypeScript definition file.
 *
 * Turns a list of CSS module keys into a TypeScript interface definition.
 */
export function generateModuleTypeDefinition( cssModuleKeys: string[], pascalCaseFileName: string, ): string {
	const interfaceName = `I${pascalCaseFileName}`;
	const moduleName = `${pascalCaseFileName}Module`;
	const namespaceName = `${pascalCaseFileName}Namespace`;


	const interfaceProperties = [ ...cssModuleKeys ]
		.sort()
		.map( ( key: string ) => {
			if ( key.includes( '-' ) ) {
				return `\t\t'${key}': string;`;
			}
			return `\t\t${key}: string;`;
		} )
		.join( '\n' );

	return `// Autogenerated by lipemat:css-module-types.
declare namespace ${namespaceName} {
	export interface I${pascalCaseFileName} {
${interfaceProperties}
	}
}

declare const ${moduleName}: ${namespaceName}.${interfaceName};

export = ${moduleName};
`;
}


/**
 * Write the typing file if it does not exist or if the content has changed.
 */
export function writeTypingsFile( fileName: string, content: string ): void {
	if ( ! existsSync( fileName ) ) {
		fs.writeFileSync( fileName, content );
	} else {
		const existingContent = readFileSync( fileName, 'utf8' );
		if ( existingContent !== content ) {
			fs.writeFileSync( fileName, content );
		}
	}
}

/**
 * Extracts CSS module keys from the content of a CSS Module file.
 *
 * @param {string} content      - The content of the CSS Module file.
 * @param {string} resourcePath - The path of the CSS Module file.
 * @return {string[]} - An array of unique CSS module keys.
 */
async function getCssModuleKeys( content: string, resourcePath: string ): Promise<string[]> {
	const result: postcss.Result = await postcss( [ localByDefault, extractImports, modulesScope ] ).process( content, {
		from: resourcePath,
		to: resourcePath,
	} );

	const classes = new Set<string>();
	result.root.walkRules( ':export', ( rule: postcss.Rule ) => {
		rule.walkDecls( ( decl: postcss.Declaration ) => {
			classes.add( camelCase( decl.prop ) );
		} );
	} );
	return Array.from( classes );
}


export default function cssModuleTypes(): Plugin {
	return {
		name: 'lipemat:css-module-types',

		// Genereate all CSS module typings on build.
		config: (): Pick<UserConfig, 'css'> => {
			return {
				css: {
					modules: {
						getJSON: ( fileName, keys ): void => {
							const typingsPath = fileName.replace( /\.pcss$/, '.pcss.d.ts' );
							const cssModuleKeys = Object.keys( keys );
							const cssModuleDefinition = generateModuleTypeDefinition( cssModuleKeys, camelCase( basename( fileName ), true ) );

							if ( 0 < cssModuleKeys.length ) {
								writeTypingsFile( typingsPath, cssModuleDefinition );
							}
						},
					},
				},
			};
		},

		// Generate CSS module typings on change during `serve`.
		configureServer: ( server: ViteDevServer ): void => {
			server.watcher.on( 'change', async fileName => {
				if ( ! fileName.endsWith( `.pcss` ) ) {
					return;
				}
				const typingsPath = fileName.replace( /\.pcss$/, '.pcss.d.ts' );
				const content = readFileSync( fileName, 'utf8' );

				const cssModuleKeys = await getCssModuleKeys( content, fileName );

				if ( 0 < cssModuleKeys.length ) {
					const cssModuleDefinition = generateModuleTypeDefinition( cssModuleKeys, camelCase( basename( fileName ), true ) );
					writeTypingsFile( typingsPath, cssModuleDefinition );
				}
			} );
			server.watcher.on( 'unlink', ( fileName: string ): void => {
				if ( ! fileName.endsWith( `.pcss` ) ) {
					return;
				}

				try {
					unlinkSync( fileName + '.d.ts' );
				} catch {
				}
			} );
		},
	};
}
